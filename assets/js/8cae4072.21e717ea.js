"use strict";(self.webpackChunkidentus_documentation_portal=self.webpackChunkidentus_documentation_portal||[]).push([[1650],{45657:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(74848),s=n(28453);const a={},o="Onboard",r={id:"identus/identus-cloud-agent/onboard",title:"Onboard",description:"Onboard enables requesting and obtaining a Decentralized Identifier (DID)",source:"@site/documentation/home/identus/identus-cloud-agent/onboard.md",sourceDirName:"identus/identus-cloud-agent",slug:"/identus/identus-cloud-agent/onboard",permalink:"/docs/home/identus/identus-cloud-agent/onboard",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},d={},c=[{value:"Getting a DID",id:"getting-a-did",level:2},{value:"Code example",id:"code-example",level:2},{value:"Server side",id:"server-side",level:3},{value:"Holder side - wallet integration with TypeScript Wallet SDK",id:"holder-side---wallet-integration-with-typescript-wallet-sdk",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const t={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"onboard",children:"Onboard"}),"\n",(0,i.jsx)(t.p,{children:"Onboard enables requesting and obtaining a Decentralized Identifier (DID)\nfrom another party. This product aims to facilitate onboarding\nsystems based on SSI. The obtained DID can then be input into various SSI-based services, such as authentication using a DID."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note"}),": This process occurs out-of-band, not using DIDComm. Please see the",(0,i.jsx)(t.br,{}),"\n","Connect product page if you want to use DIDComm-based agent-to-agent services."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"getting-a-did",children:"Getting a DID"}),"\n",(0,i.jsx)(t.p,{children:"On a high level, the process of obtaining a DID includes creating a DID request,\nencoding it, and sending it to the other party. The other party then uses their\nwallet to scan/receive the DID request and send back the existing or new DID."}),"\n",(0,i.jsx)(t.p,{children:"Let's go through the whole process in more detail."}),"\n",(0,i.jsx)(t.p,{children:'The inviting party creates a so-called "DID request." An example of a request state:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n  "self": "https://demo.atalaprism.io/did-requests/did-request-1234",\n  "kind": "DidRequestState",\n  "id": "did-request-1234",\n  "didRequest": {\n    "type": "https://atalaprism.io/did-request",\n    "onboardEndpoint": "https://demo.atalaprism.io:8085/request-id-1234",\n    "from": "Application ABC"\n  },\n  "did": null,\n  "state": "pending",\n  "createdAt": "2023-02-24T10:22:23Z",\n  "updatedAt": "2023-02-24T10:22:23Z"\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["It contains the ",(0,i.jsx)(t.code,{children:"didRequest"})," field and other metadata that makes tracking the requesting possible."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note"}),": Only the ",(0,i.jsx)(t.code,{children:"didRequest"})," field should be encoded and sent to the other side!"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The optional ",(0,i.jsx)(t.code,{children:"from"})," field could be added too. It is a human-readable label that\nrepresents the inviting party. Wallets could use this label later to display\ninformation to users about who is sending request."]}),"\n",(0,i.jsxs)(t.p,{children:["The initial state is ",(0,i.jsx)(t.code,{children:"pending"}),", and ",(0,i.jsx)(t.code,{children:"did"})," field is ",(0,i.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Next, the ",(0,i.jsx)(t.code,{children:"didRequest"})," object is encoded depending on the use case, typically as a QR code or deep link. The encoded request gets sent to the other party via an appropriate channel: email, chat message, or presenting directly in a web app."]}),"\n",(0,i.jsxs)(t.p,{children:["Now, the receiving party uses their wallet to decode and process the received\nDID request. The type of message is identifiable by the ",(0,i.jsx)(t.code,{children:"type"})," field. In the case of DID\nrequest, it is ",(0,i.jsx)(t.code,{children:"https://atalaprism.io/did-request"}),". The wallet then should\npresent a prompt to the user to accept or reject the request, showing optionally\n",(0,i.jsx)(t.code,{children:"from"})," label. If the user accepts the request, the wallet creates a new\nrelationship and sends its DID back to the ",(0,i.jsx)(t.code,{children:"onboardEndpoint"})," specified in the\nDID request."]}),"\n",(0,i.jsxs)(t.p,{children:["During the process, the inviting party can query the sent DID request's state to check the response status. The terminal state is either ",(0,i.jsx)(t.code,{children:"error"})," or\n",(0,i.jsx)(t.code,{children:"success"})," with received DID in ",(0,i.jsx)(t.code,{children:"did"})," field. Once the DID is received, depending\non the business logic, the application can act upon it, for example, associate\nit with a user ID in the main application state."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note"}),": DID request is for one-time use only. The request is invalidated if the response is received and is not reusable."]}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note"}),": Currently, if a DID is under the other party's control, there is no mechanism to verify.. See Authenticate API if such a feature is required."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"code-example",children:"Code example"}),"\n",(0,i.jsx)(t.p,{children:"Here is the code example of the process of adding a DID to an existing user\nprofile:"}),"\n",(0,i.jsx)(t.h3,{id:"server-side",children:"Server side"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'/**\n * This is an example of a server side handler. Imagine a web application which \n * has a "Connect with DID" button on the user profile page, which triggers this\n * flow.\n */\nasync function createDidRequest(context) {\n  // get the existing user profile from the application database for a given userId\n  let userProfile = await getUserById(context.userId);\n\n  // to interact with Onboard API, we use an API client generated based on OpenAPI\n  // specification, with a tool such as Orval.\n  let didRequestState = await prismApiClient.createDidRequest({\n    from: "Application ABC"\n  })\n\n  // depends on the use-case: deep link, QR code, or something else!\n  let encodedDidRequest = encodeAsDeepLink(didRequestState.didRequest);\n  \n  // could be any communication channel, we use email here as an example\n  await sendDidRequestToEmail(userProfile.email, encodedDidRequest);\n  \n  // track the state of DID request in the background - no events yet!\n  await scheduleBackgroundTrackingJob({\n    requestId: didRequestState.id, \n    userId: context.userId\n  });\n  await respondWithSuccessToApplicationFrontend();\n  \n  console.info(`DID request "${didRequestState.id}" has been created and sent to user.`);\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Since there is no eventing mechanism currently, the application should\nperiodically check the state of the DID request. For example, this could be a way\nto implement a processing step in a background job:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'async function checkDidRequest(didRequestId, userId) {\n  let didRequestState = await prismApiClient.getDidRequest(didRequestId);\n\n  if (didRequestState.state === "error") {\n    console.log(`DID request (${didRequestState.id}) for ${userId} has been either rejected or failed`);\n    await cancelBackgroundTrackingJob();\n    return;\n  } \n  \n  if (didRequestState.did) {\n    console.log(`Received a DID (`${didRequestState.did}`) from ${userId} at ${didRequestState.updatedAt}`);\n    await updateUserProfile(userId, {did: didRequestState.did});\n    await cancelBackgroundTrackingJob();\n    return;\n  }\n  \n  // ...still no response, wait for next check iteration\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"holder-side---wallet-integration-with-typescript-wallet-sdk",children:"Holder side - wallet integration with TypeScript Wallet SDK"}),"\n",(0,i.jsx)(t.p,{children:"Wallets and other applications can use the TypeScript SDK to create DIDs to respond to DID requests. Here is an example of how to do it:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note"}),": See Wallet SDK documentation for more information on how to use it."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'import {Apollo, Castor, Domain} from "@input-output-hk/atala-prism-wallet-sdk";\n\n// init Apollo and Castor SDK modules. \n// Apollo = cryptography, Castor = DIDs management.\nconst apollo = new Apollo();\nconst castor = new Castor(apollo);\n\n/**\n * Wallet will receive encoded DID request as a deep link, QR code, or in some\n * other way. This is the function which will handle decoded DID request. This \n * is just a simple example where new Peer DID is created and sent back to the \n * Onboard service. In a real-world application, there would be some more \n * complex flow in which user would be asked to confirm the request, and create\n * a new contact or avatar in the wallet (or select an existing one).\n *\n * @param {type, from, onboardEndpoint} didRequest\n */\nasync function handleDidRequest(didRequest) {\n    if (didRequest.type !== "https://atalaprism.io/did-request") {\n        throw new Error("Invalid DID request");\n    }\n\n    // create new authentication and key agreement key pairs, and use them to \n    // create a new Peer DID. Onboard service accepts any DID, but if you plan\n    // to use it with Authenticate, you should use Peer DIDs.\n    const authKeyPair = apollo.createKeyPairFromKeyCurve({\n        curve: Domain.Curve.ED25519,\n    });\n    const keyAgreementKeyPair = apollo.createKeyPairFromKeyCurve({\n        curve: Domain.Curve.X25519,\n    });\n    const peerDID = await castor.createPeerDID(\n        [authKeyPair, keyAgreementKeyPair],\n        []\n    );\n    const didStr = peerDID.toString();\n    \n    const newContact = {\n        name: didRequest.from,\n        did: didStr,\n        keys: [authKeyPair, keyAgreementKeyPair]\n    };\n    \n    // store the new contact in the wallet database\n    await storeContact(newContact);\n    \n    // POST created DID back to the Onboard service - using axios for example\n    await axios.post(didRequestReceived.onboardEndpoint, {\n        did: didStr,\n    });\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"In the previous section, we discussed the process of obtaining a DID. Typically,\nthe requesting party is an application aiming to extend its feature set with SSI\ncapabilities, and the receiving party is a user with their own SSI wallet. The\nOnboard service that helps to facilitate obtaining a DID by providing necessary abstractions and state\nmanagement. We also provided a code example of using the Onboard API from\nboth sides of the process."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(96540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);