"use strict";(self.webpackChunkidentus_documentation_portal=self.webpackChunkidentus_documentation_portal||[]).push([[3049],{59553:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=r(74848),t=r(28453);const o={},a="Use ZIO Failures and Defects Effectively",s={id:"decisions/2024-01-16-use-zio-failures-and-defects-effectively",title:"Use ZIO Failures and Defects Effectively",description:"- Status: accepted",source:"@site/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md",sourceDirName:"decisions",slug:"/decisions/2024-01-16-use-zio-failures-and-defects-effectively",permalink:"/identus-docs/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"adrsSidebar",previous:{title:"Error Handling Report Problem for Agent",permalink:"/identus-docs/adrs/decisions/2024-01-15-Error-handling-report-problem-agent"},next:{title:"Handle errors in background jobs by storing on state records and sending via webhooks",permalink:"/identus-docs/adrs/decisions/2024-03-07-handle-errors-in-bg-jobs-by-storing-on-state-records-and-sending-via-webhooks"}},l={},c=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Decision Drivers",id:"decision-drivers",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Option 1: Continue With The Current Error Handling Strategy",id:"option-1-continue-with-the-current-error-handling-strategy",level:3},{value:"Option 2: Leverage ZIO Failures And Defects Effectively",id:"option-2-leverage-zio-failures-and-defects-effectively",level:3},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Option 2 - General Implementation Rules and Principles",id:"option-2---general-implementation-rules-and-principles",level:2},{value:"Case 1: When designing a component or service",id:"case-1-when-designing-a-component-or-service",level:3},{value:"Carefully Segregate Error Types",id:"carefully-segregate-error-types",level:4},{value:"Use ADT to Model ZIO Failures",id:"use-adt-to-model-zio-failures",level:4},{value:"Use Scala 3 Union Types to Be More Specific About ZIO Failure Types",id:"use-scala-3-union-types-to-be-more-specific-about-zio-failure-types",level:4},{value:"Don\u2019t Type Unexpected Errors (i.e. ZIO Defects)",id:"dont-type-unexpected-errors-ie-zio-defects",level:4},{value:"Case 2: When calling an existing component or service",id:"case-2-when-calling-an-existing-component-or-service",level:3},{value:"Only Catch Failures You Effectively Handle",id:"only-catch-failures-you-effectively-handle",level:4},{value:"Use Failure Wrappers To Prevent Failures Leakage From Lower Layers",id:"use-failure-wrappers-to-prevent-failures-leakage-from-lower-layers",level:4},{value:"Do not reflexively log errors",id:"do-not-reflexively-log-errors",level:4},{value:"Adopt The \u201cLet it Crash\u201d Principle For ZIO Defects",id:"adopt-the-let-it-crash-principle-for-zio-defects",level:4},{value:"Option 2 - Practical Implementation",id:"option-2---practical-implementation",level:2},{value:"Repository Layer",id:"repository-layer",level:3},{value:"Try using defects only (<code>UIO</code> or <code>URIO</code>)",id:"try-using-defects-only-uio-or-urio",level:4},{value:"Apply the <code>get</code> vs <code>find</code> pattern",id:"apply-the-get-vs-find-pattern",level:4},{value:"Do not return the affected row count",id:"do-not-return-the-affected-row-count",level:4},{value:"Do not reflexively log errors",id:"do-not-reflexively-log-errors-1",level:4},{value:"Service Layer",id:"service-layer",level:3},{value:"Reporting <code>404 Not Found</code> to user",id:"reporting-404-not-found-to-user",level:4},{value:"Do not type unexpected errors",id:"do-not-type-unexpected-errors",level:4},{value:"Extend the common <code>Failure</code> trait",id:"extend-the-common-failure-trait",level:4},{value:"User Input Validation",id:"user-input-validation",level:4},{value:"Use Scala 3 Union Types",id:"use-scala-3-union-types",level:4},{value:"Do not reflexively log errors",id:"do-not-reflexively-log-errors-2",level:4},{value:"Controller Layer",id:"controller-layer",level:3},{value:"Reporting RFC-9457 Error Response",id:"reporting-rfc-9457-error-response",level:4},{value:"Use &quot;Failure =&gt; ErrorResponse&quot; Implicit Conversion",id:"use-failure--errorresponse-implicit-conversion",level:4},{value:"Do not reflexively log errors",id:"do-not-reflexively-log-errors-3",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"use-zio-failures-and-defects-effectively",children:"Use ZIO Failures and Defects Effectively"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Status: accepted"}),"\n",(0,i.jsx)(n.li,{children:"Deciders: Fabio Pinheiro, Shailesh Patil, Pat Losoponkul, Yurii Shynbuiev, David Poltorak, Benjamin Voiturier"}),"\n",(0,i.jsx)(n.li,{children:"Date: 2024-03-29"}),"\n",(0,i.jsx)(n.li,{children:"Tags: error-handling, zio"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,i.jsx)(n.p,{children:"ZIO is a powerful and purely functional library for building scalable and resilient applications in Scala. However,\neffectively handling errors within the context of ZIO presents challenges that must be addressed."}),"\n",(0,i.jsx)(n.p,{children:"Within our software development projects utilising ZIO, the management and handling of errors have emerged as areas\nrequiring more clarity and strategy. The existing practices have shown limitations in terms of their efficiency and\ncomprehensiveness."}),"\n",(0,i.jsx)(n.p,{children:"The key issues are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lack of Consistent Error Handling Strategies"}),": There's inconsistency in error handling across different modules\nand components of our ZIO-based applications, making it challenging to maintain a unified approach."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Understanding and Communicating Errors"}),": There's a need for a clearer method to categorise errors and communicate\nthese effectively within the team and across various layers, facilitating quicker identifications and resolutions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimising Error Recovery Mechanisms"}),": While ZIO provides powerful abstractions for error recovery, there's a\nnecessity to optimise these mechanisms to ensure graceful degradation and resilience in our applications."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ADR aims to explore and define strategies for utilising ZIO's capabilities more effectively in handling errors. It\nwill outline decision drivers, available options, their pros and cons, and ultimately, the recommended approach to\nenhance our error management practices with the ZIO framework."}),"\n",(0,i.jsx)(n.p,{children:"Effective management of errors directly impacts the reliability, maintainability, and customer experience of our\napplications."}),"\n",(0,i.jsx)(n.p,{children:"By addressing the challenges of consistent error handling, we aim to enhance the stability of our products, ensuring\nreduced downtime, clearer communication with customers through structured error messages, and quicker issue\nresolution."}),"\n",(0,i.jsx)(n.p,{children:"This not only improves the overall customer experience but also accelerates feature delivery as developers can focus\nmore on implementing new functionalities rather than troubleshooting ad-hoc errors. The resulting streamlined\ndevelopment process contributes to cost reduction and optimised resource allocation."}),"\n",(0,i.jsx)(n.p,{children:"In essence, these efforts are customer-centric, aiming to deliver a reliable, efficient, and customer-friendly service\ninterface that positively impacts the overall customer experience and product adoption."}),"\n",(0,i.jsx)(n.h2,{id:"decision-drivers",children:"Decision Drivers"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency and Standardization"}),": A consistent and standardised approach to error handling across different\nmodules and components of our ZIO applications is crucial. This consistency will ease code readability, maintenance,\nand team collaboration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness and Resilience"}),": A key driver is to harden our applications against failures by leveraging ZIO's\npowerful error recovery mechanisms. Enhancing the robustness of our applications will improve their resilience in\nadverse conditions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Traceability and Debugging"}),": Reducing debugging time and efforts associated with error resolution is another\ndriving factor. An efficient error-handling strategy should enable traceability and quicker identification,\ncommunication, and resolution of errors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Experience and Reliability"}),": Improving the quality and clarity of error messages reported to our users is a\nkey driver. We aim to refine error messages to enable users to better understand what\u2019s going on and respond to\nissues,\nthereby enhancing the user experience and the overall reliability of our applications."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Alignment with Best Practices"}),": Aligning our error-handling strategies with industry best practices and leveraging\nthe full potential of ZIO's error management features is a driver. Adhering to established standards can lead to more\neffective and maintainable code."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,i.jsx)(n.h3,{id:"option-1-continue-with-the-current-error-handling-strategy",children:"Option 1: Continue With The Current Error Handling Strategy"}),"\n",(0,i.jsx)(n.p,{children:'Continuing with the existing "so-so" error handling strategy currently in place within our ZIO applications without\nsignificant modifications or improvements.'}),"\n",(0,i.jsx)(n.p,{children:"Pros:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintains continuity with current practices, potentially requiring minimal adjustments and avoiding immediate\ndisruptions to ongoing projects."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Cons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inconsistencies in the code base across the components and services may persist, leading to potential challenges in\nmaintenance and scalability."}),"\n",(0,i.jsx)(n.li,{children:"Engineers may spend time reinventing error-handling solutions rather than leveraging established best practices or\nframeworks."}),"\n",(0,i.jsx)(n.li,{children:"No significant improvement in terms of traceability and problem debugging, potentially hindering the resolution of\nissues and defects."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"option-2-leverage-zio-failures-and-defects-effectively",children:"Option 2: Leverage ZIO Failures And Defects Effectively"}),"\n",(0,i.jsx)(n.p,{children:"Adopting best practices for error handling within ZIO applications and effectively utilising ZIO Failures and Defects,\ndefining and implementing stricter guidelines and protocols for error handling."}),"\n",(0,i.jsx)(n.p,{children:"Pros:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ensures adherence to established best practices, promoting code consistency, reliability, and scalability across\nvarious components and services."}),"\n",(0,i.jsx)(n.li,{children:"Reduces the need for developers to reinvent error-handling solutions, allowing them to leverage proven strategies and\nframeworks."}),"\n",(0,i.jsx)(n.li,{children:"Improves traceability and problem debugging by employing standardised error-handling practices, facilitating quicker\nissue identification and resolution."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Cons:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Will require adjustments to current code and practices, necessitating time and effort for implementation.Actual impact\nand workload still needs to be identified."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,i.jsxs)(n.p,{children:["It has been decided to pursue Option 2: ",(0,i.jsx)(n.strong,{children:"Leverage ZIO Failures and Defects Effectively"}),". This decision aligns with our\ncommitment to enhancing the reliability, scalability, and maintainability of our applications."]}),"\n",(0,i.jsx)(n.p,{children:"While we acknowledge this option requires more refactoring, its long-term benefits in terms of code quality, developer\nefficiency, and robust error management outweigh the associated refactoring efforts."}),"\n",(0,i.jsx)(n.h2,{id:"option-2---general-implementation-rules-and-principles",children:"Option 2 - General Implementation Rules and Principles"}),"\n",(0,i.jsx)(n.h3,{id:"case-1-when-designing-a-component-or-service",children:"Case 1: When designing a component or service"}),"\n",(0,i.jsx)(n.h4,{id:"carefully-segregate-error-types",children:"Carefully Segregate Error Types"}),"\n",(0,i.jsx)(n.p,{children:"When designing a new component or service, the nature of anticipated errors should be carefully considered, and a clear\ndistinction between expected errors (i.e. ZIO Failures or domain-specific errors) and unexpected errors (i.e. ZIO\nDefects) should be made."}),"\n",(0,i.jsxs)(n.p,{children:["This segregation should be done according to the principles outlined in\nthe ",(0,i.jsx)(n.a,{href:"https://zio.dev/reference/error-management/types",children:"ZIO Types of Errors"})," documentation section.\nThat is, carefully distinguishing between:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"ZIO Failures"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The expected/recoverable errors (i.e. domain-specific errors)."}),"\n",(0,i.jsx)(n.li,{children:"Declared in the Error channel of the effect => ZIO[R, E, A]."}),"\n",(0,i.jsx)(n.li,{children:"Supposed to be handled by the caller to prevent call stack propagation."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"ZIO Defects"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The unexpected/unrecoverable errors."}),"\n",(0,i.jsx)(n.li,{children:"Not represented in the ZIO effect."}),"\n",(0,i.jsx)(n.li,{children:"We do NOT expect the caller to handle them."}),"\n",(0,i.jsx)(n.li,{children:"Propagated throughout the call stack until converted to a Failure or logged for traceability and debugging\npurposes by\nthe uppermost layer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"use-adt-to-model-zio-failures",children:"Use ADT to Model ZIO Failures"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.strong,{children:"Algebraic Data Types"})," (ADTs) to model domain-specific errors as ZIO failures within the component/service\ninterface."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Implementation tips:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use a sealed trait or abstract class"})," to represent the hierarchy of ZIO Failures, allowing for a well-defined set\nof error possibilities."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Define specific error cases within the companion object"})," of the sealed trait. This practice prevents potential\nconflicts when importing errors with common names (e.g. RecordNotFoundError), allowing users to prefix them with the\nname of the parent sealed trait for better code clarity."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"sealed trait DomainError\n\nobject DomainError {\n  final case class BusinessLogicError(message: String) extends DomainError\n\n  final case class DataValidationError(message: String) extends DomainError\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"use-scala-3-union-types-to-be-more-specific-about-zio-failure-types",children:"Use Scala 3 Union Types to Be More Specific About ZIO Failure Types"}),"\n",(0,i.jsx)(n.p,{children:"Using the Scala 3 Union Types feature to declare the expected failures of a ZIO effect should be preferred over using\nthe broader and more generic top-level sealed trait. This allows for a more explicit and detailed definition of\npotential failure scenarios and enhances error handling accuracy on the caller side."}),"\n",(0,i.jsxs)(n.p,{children:["This principle is outlined in\nthe ",(0,i.jsx)(n.a,{href:"https://zio.dev/reference/error-management/best-practices/union-types",children:"following section"})," of the ZIO Error\nManagement Best Practices documentation."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait MyService {\n  def myMethod(): ZIO[Any, BusinessLogicError | DataValidationError, Unit]\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"dont-type-unexpected-errors-ie-zio-defects",children:"Don\u2019t Type Unexpected Errors (i.e. ZIO Defects)"}),"\n",(0,i.jsx)(n.p,{children:"When we first discover typed errors, it may be tempting to put every error into the ZIO failure type parameter/channel.\nThat is a mistake because we can't recover from all types of errors. When we encounter unexpected errors we can't do\nanything with, we should let the application die (i.e. the ZIO fiber). This is known as the \u201cLet it Crash\u201d principle,\nand it is a good approach for all unexpected errors."}),"\n",(0,i.jsxs)(n.p,{children:["This principle is outlined in\nthe ",(0,i.jsx)(n.a,{href:"https://zio.dev/reference/error-management/best-practices/unexpected-errors",children:"following section"})," of the ZIO Error\nManagement Best Practices documentation."]}),"\n",(0,i.jsx)(n.h3,{id:"case-2-when-calling-an-existing-component-or-service",children:"Case 2: When calling an existing component or service"}),"\n",(0,i.jsx)(n.h4,{id:"only-catch-failures-you-effectively-handle",children:"Only Catch Failures You Effectively Handle"}),"\n",(0,i.jsx)(n.p,{children:"As a user of an existing component or service, you should exclusively catch failures that you are prepared to\neffectively handle. Any unhandled failures should be transformed into defects and propagated through the call stack. You\nshould not expect callers of your component to handle lower-level failures that you do not handle."}),"\n",(0,i.jsx)(n.h4,{id:"use-failure-wrappers-to-prevent-failures-leakage-from-lower-layers",children:"Use Failure Wrappers To Prevent Failures Leakage From Lower Layers"}),"\n",(0,i.jsx)(n.p,{children:"Do not directly expose their failure types in your component interface when invoking lower-level components. Use\nwrappers to encapsulate and abstract failure types originating from lower-level components, thus enhancing\nloose coupling and safeguarding against leakage of underlying implementation details to the caller."}),"\n",(0,i.jsxs)(n.p,{children:["Using failure wrappers and propagating them ",(0,i.jsx)(n.strong,{children:"should not be the default strategy"}),". Lower-level failures should\nprimarily\nbe managed at your component implementation level, ensuring that it appropriately handles and recovers them."]}),"\n",(0,i.jsx)(n.p,{children:"Failures not handled within the component's boundaries should preferably be transformed into defects whenever possible."}),"\n",(0,i.jsx)(n.h4,{id:"do-not-reflexively-log-errors",children:"Do not reflexively log errors"}),"\n",(0,i.jsxs)(n.p,{children:["Avoid catching a ZIO failure or defect solely for the purpose of logging it. Instead, consider allowing the error to\npropagate through the call stack. It's preferable to assume that the uppermost layer, commonly known as ",(0,i.jsx)(n.strong,{children:"'the end of\nthe world' will handle the logging"})," of those errors. This practice promotes a centralised and consistent logging\napproach for better traceability and debugging."]}),"\n",(0,i.jsxs)(n.p,{children:["This principle is outlined in\nthe ",(0,i.jsx)(n.a,{href:"https://zio.dev/reference/error-management/best-practices/logging-errors",children:"following section"})," of the ZIO Error\nManagement Best Practices documentation."]}),"\n",(0,i.jsx)(n.h4,{id:"adopt-the-let-it-crash-principle-for-zio-defects",children:"Adopt The \u201cLet it Crash\u201d Principle For ZIO Defects"}),"\n",(0,i.jsx)(n.p,{children:"Adopt the \u201cLet it Crash\u201d principle for ZIO defects. Let them bubble up the call stack and crash the current ZIO fiber.\nThey will be handled/recovered at a higher level or logged appropriately \u201cat the end of the world\u201d by the uppermost\nlayer."}),"\n",(0,i.jsx)(n.h2,{id:"option-2---practical-implementation",children:"Option 2 - Practical Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"repository-layer",children:"Repository Layer"}),"\n",(0,i.jsxs)(n.h4,{id:"try-using-defects-only-uio-or-urio",children:["Try using defects only (",(0,i.jsx)(n.code,{children:"UIO"})," or ",(0,i.jsx)(n.code,{children:"URIO"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The repository layer leverages Doobie,\nwhich ",(0,i.jsx)(n.a,{href:"https://tpolecat.github.io/doobie/docs/09-Error-Handling.html#about-exceptions",children:"natively relies on unchecked exceptions"}),".\nDoobie will report any database error as a subclass of ",(0,i.jsx)(n.code,{children:"Throwable"}),", and its specific type will be directly\nlinked to the underlying database implementation (i.e. PostgreSQL). Handling it this way means there is no deterministic\nway to recover\nfrom an SQL execution error in a database-agnostic way."]}),"\n",(0,i.jsxs)(n.p,{children:["A good approach is to use ZIO Defects to report repository errors, declaring all repository methods as ",(0,i.jsx)(n.code,{children:"URIO"}),"\nor ",(0,i.jsx)(n.code,{children:"UIO"}),"(",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/main/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/repository/ConnectionRepository.scala",children:"example"}),").\nConversely, declaring them as ",(0,i.jsx)(n.code,{children:"Task"})," assumes that the caller (i.e. service) can properly handle and\nrecover from the low-level and database-specific exceptions exposed in the error channel, which is a fallacy."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ConnectionRepository {\n  def findAll: URIO[WalletAccessContext, Seq[ConnectionRecord]]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Converting a ZIO ",(0,i.jsx)(n.code,{children:"Task"})," to ZIO ",(0,i.jsx)(n.code,{children:"UIO"})," can easily be done\nusing ",(0,i.jsx)(n.code,{children:"ZIO#orDie"}),"(",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/sql-doobie/src/main/scala/io/iohk/atala/connect/sql/repository/JdbcConnectionRepository.scala#L114",children:"example"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'class JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def findAll: URIO[WalletAccessContext, Seq[ConnectionRecord]] = {\n    val cxnIO =\n      sql"""\n           | SELECT\n           |   id,\n           |   created_at,\n           |   ...\n           | FROM public.connection_records\n           | ORDER BY created_at\n        """.stripMargin\n        .query[ConnectionRecord]\n        .to[Seq]\n\n    cxnIO\n      .transactWallet(xa)\n      .orDie\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For those cases where one has to generate a defect, a common way to do this is by using the following ZIO\nconstruct (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/sql-doobie/src/main/scala/io/iohk/atala/connect/sql/repository/JdbcConnectionRepository.scala#L212",children:"example"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'class JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def getById(recordId: UUID): URIO[WalletAccessContext, ConnectionRecord] =\n    for {\n      maybeRecord <- findById(recordId)\n      record <- ZIO.fromOption(maybeRecord).orDieWith(_ => RuntimeException(s"Record not found: $recordId"))\n    } yield record\n}\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"apply-the-get-vs-find-pattern",children:["Apply the ",(0,i.jsx)(n.code,{children:"get"})," vs ",(0,i.jsx)(n.code,{children:"find"})," pattern"]}),"\n",(0,i.jsxs)(n.p,{children:["Follow the ",(0,i.jsx)(n.code,{children:"get"})," and ",(0,i.jsx)(n.code,{children:"find"})," best practices in the repository interface for read operations:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getXxx()"})," returns the requested record or throws an unexpected exception/defect when not\nfound (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/repository/ConnectionRepository.scala#L36",children:"example"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"findXxx()"})," returns an ",(0,i.jsx)(n.code,{children:"Option"})," with or without the request record, which allows the caller service to handle\nthe ",(0,i.jsx)(n.code,{children:"found"}),"\nand ",(0,i.jsx)(n.code,{children:"not-found"})," cases and report appropriately to the end\nuser (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/repository/ConnectionRepository.scala#L32",children:"example"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"trait ConnectionRepository {\n  def findById(recordId: UUID): URIO[WalletAccessContext, Option[ConnectionRecord]]\n\n  def getById(recordId: UUID): URIO[WalletAccessContext, ConnectionRecord]\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"do-not-return-the-affected-row-count",children:"Do not return the affected row count"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"create"}),", ",(0,i.jsx)(n.code,{children:"update"})," or ",(0,i.jsx)(n.code,{children:"delete"})," repository methods should not return an ",(0,i.jsx)(n.code,{children:"Int"})," indicating the number of rows affected\nby the operation but either return ",(0,i.jsx)(n.code,{children:"Unit"})," when successful or throw an exception/defect when the row count is not what is\nexpected, like i.e. an update operation resulting in a ",(0,i.jsx)(n.code,{children:"0"})," affected row\ncount (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/sql-doobie/src/main/scala/io/iohk/atala/connect/sql/repository/JdbcConnectionRepository.scala#L85",children:"example"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'class JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def create(record: ConnectionRecord): URIO[WalletAccessContext, Unit] = {\n    val cxnIO =\n      sql"""\n           | INSERT INTO public.connection_records(\n           |   id,\n           |   created_at,\n           |   ...\n           | ) values (\n           |   ${record.id},\n           |   ${record.createdAt},\n           |   ...\n           | )\n        """.stripMargin.update\n\n    cxnIO.run\n      .transactWallet(xa)\n      .ensureOneAffectedRowOrDie\n  }\n}\n\nextension[Int](ma: RIO[WalletAccessContext, Int]) {\n  def ensureOneAffectedRowOrDie: URIO[WalletAccessContext, Unit] = ma.flatMap {\n    case 1 => ZIO.unit\n    case count => ZIO.fail(RuntimeException(s"Unexpected affected row count: $count"))\n  }.orDie\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"do-not-reflexively-log-errors-1",children:"Do not reflexively log errors"}),"\n",(0,i.jsx)(n.p,{children:"The upper layer will automatically do so appropriately and consistently using Tapir interceptor customization."}),"\n",(0,i.jsx)(n.h3,{id:"service-layer",children:"Service Layer"}),"\n",(0,i.jsxs)(n.h4,{id:"reporting-404-not-found-to-user",children:["Reporting ",(0,i.jsx)(n.code,{children:"404 Not Found"})," to user"]}),"\n",(0,i.jsxs)(n.p,{children:["How can a service appropriately report a ",(0,i.jsx)(n.code,{children:"404 Not Found"})," to a user that i.e. tries to update a record\nthat does not exist in the database? Following the above rules, the ",(0,i.jsx)(n.code,{children:"update"})," method will throw a defect that will be\ncaught at the upper level and returns a generic ",(0,i.jsx)(n.code,{children:"500 Internal Server Error"})," to the user."]}),"\n",(0,i.jsxs)(n.p,{children:["For those cases where a specific error like ",(0,i.jsx)(n.code,{children:"404"})," should be returned, it is up to the service to first call ",(0,i.jsx)(n.code,{children:"find()"}),"\nbefore ",(0,i.jsx)(n.code,{children:"update()"})," and construct a ",(0,i.jsx)(n.code,{children:"NotFound"})," failure, propagated through the error channel, if it gives\na ",(0,i.jsx)(n.code,{children:"None"})," (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/service/ConnectionServiceImpl.scala#L149",children:"example"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"Relying on the service layer to implement it will guarantee consistent behavior regardless of the underlying database\ntype (could be different RDMS flavor, No-SQL, etc.)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"class ConnectionServiceImpl() extends ConnectionService {\n  override def markConnectionRequestSent(recordId: UUID):\n  ZIO[WalletAccessContext, RecordIdNotFound | InvalidStateForOperation, ConnectionRecord] =\n    for {\n      maybeRecord <- connectionRepository.findById(recordId)\n      record <- ZIO.fromOption(maybeRecord).mapError(_ => RecordIdNotFound(recordId))\n      updatedRecord <- updateConnectionProtocolState(\n        recordId,\n        ProtocolState.ConnectionRequestPending,\n        ProtocolState.ConnectionRequestSent\n      )\n    } yield updatedRecord\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"do-not-type-unexpected-errors",children:"Do not type unexpected errors"}),"\n",(0,i.jsxs)(n.p,{children:["Do not wrap defects from lower layers (typically repository) in a failure and error case class declarations\nlike ",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/b579fd86ab96db711425f511154e74be75583896/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/model/error/ConnectionServiceError.scala#L8",children:"this"}),"\nshould be prohibited."]}),"\n",(0,i.jsxs)(n.p,{children:["Considering that failures are viewed as ",(0,i.jsx)(n.strong,{children:"expected errors"})," from which users can potentially recover, error case classes\nlike ",(0,i.jsx)(n.code,{children:"UnexpectedError"})," should be\nprohibited (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/b579fd86ab96db711425f511154e74be75583896/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/model/error/ConnectionServiceError.scala#L12",children:"example"}),")."]}),"\n",(0,i.jsxs)(n.h4,{id:"extend-the-common-failure-trait",children:["Extend the common ",(0,i.jsx)(n.code,{children:"Failure"})," trait"]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure all service errors extend the shared\ntrait ",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/main/shared/src/main/scala/io/iohk/atala/shared/models/Failure.scala",children:(0,i.jsx)(n.code,{children:"org.hyperledger.identus.shared.models.Failure"})}),'.\nThis allows handling "at the end of the world\u201c to be done in a consistent and in generic way.']}),"\n",(0,i.jsxs)(n.p,{children:["Create an exhaustive and meaningful list of service errors and make sure the value of the ",(0,i.jsx)(n.code,{children:"userFacingMessage"}),' attribute\nis chosen wisely! It will present "as is" to the user and should not contain any sensitive\ndata (',(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/model/error/ConnectionServiceError.scala#L14",children:"example"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'trait Failure {\n  val statusCode: StatusCode\n  val userFacingMessage: String\n}\n\nsealed trait ConnectionServiceError(\n                                     val statusCode: StatusCode,\n                                     val userFacingMessage: String\n                                   ) extends Failure\n\nobject ConnectionServiceError {\n  final case class InvitationAlreadyReceived(invitationId: String)\n    extends ConnectionServiceError(\n      StatusCode.BadRequest,\n      s"The provided invitation has already been used: invitationId=$invitationId"\n    )\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"user-input-validation",children:"User Input Validation"}),"\n",(0,i.jsxs)(n.p,{children:["Enforcing user input validation (business invariants) should primarily sit at the service layer and be implemented using\nthe\n",(0,i.jsx)(n.a,{href:"https://zio.dev/zio-prelude/functional-data-types/validation",children:"ZIO Prelude framework"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"While partially implementing user input validation at the REST entry point level via OpenAPI specification, it is\ncrucial to enforce validation at the service level as well. This implementation ensures consistency and reliability\nacross all interfaces that may call our services, recognizing that REST may not be the sole interface interacting with\nour services."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'class ConnectionServiceImpl() extends ConnectionService {\n  def validateInputs(\n                      label: Option[String],\n                      goalCode: Option[String],\n                      goal: Option[String]\n                    ): IO[UserInputValidationError, Unit] = {\n    val validation = Validation\n      .validate(\n        ValidationUtils.validateLengthOptional("label", label, 0, 255),\n        ValidationUtils.validateLengthOptional("goalCode", goalCode, 0, 255),\n        ValidationUtils.validateLengthOptional("goal", goal, 0, 255)\n      )\n      .unit\n    ZIO.fromEither(validation.toEither).mapError(UserInputValidationError.apply)\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Modeling validation errors should use a dedicated error case class and, when possible, provide validation failure\ndetails. One could use a construct like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:'sealed trait ConnectionServiceError(\n                                     val statusCode: StatusCode,\n                                     val userFacingMessage: String\n                                   ) extends Failure\n\nobject ConnectionServiceError {\n  final case class UserInputValidationError(errors: NonEmptyChunk[String])\n    extends ConnectionServiceError(\n      StatusCode.BadRequest,\n      s"The provided input failed validation: errors=${errors.mkString("[", "], [", "]")}"\n    )\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"use-scala-3-union-types",children:"Use Scala 3 Union Types"}),"\n",(0,i.jsxs)(n.p,{children:["Use Scala 3 union-types declaration in the effect\u2019s error channel to notify the caller of potential\nfailures (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/connect/lib/core/src/main/scala/io/iohk/atala/connect/core/service/ConnectionServiceImpl.scala#L178",children:"example"}),")"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"class ConnectionServiceImpl() extends ConnectionService {\n\n  override def receiveConnectionRequest(request: ConnectionRequest, expirationTime: Option[Duration] = None):\n  ZIO[WalletAccessContext, ThreadIdNotFound | InvalidStateForOperation | InvitationExpired, ConnectionRecord] = ???\n\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"do-not-reflexively-log-errors-2",children:"Do not reflexively log errors"}),"\n",(0,i.jsx)(n.p,{children:"The upper layer will automatically do so appropriately and consistently using Tapir interceptor customization."}),"\n",(0,i.jsx)(n.h3,{id:"controller-layer",children:"Controller Layer"}),"\n",(0,i.jsx)(n.h4,{id:"reporting-rfc-9457-error-response",children:"Reporting RFC-9457 Error Response"}),"\n",(0,i.jsxs)(n.p,{children:["All declared Tapir endpoints must\nuse ",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/main/cloud-agent/service/server/src/main/scala/io/iohk/atala/api/http/ErrorResponse.scala",children:(0,i.jsx)(n.code,{children:"org.hyperledger.identus.api.http.ErrorResponse"})}),"\nas their output error\ntype (",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/cloud-agent/service/server/src/main/scala/io/iohk/atala/connect/controller/ConnectionEndpoints.scala#L45",children:"example"}),")\nThis type ensures that the response returned to the user complies with\nthe ",(0,i.jsx)(n.a,{href:"https://www.rfc-editor.org/rfc/rfc9457.html",children:"RFC-9457 Problem Details for HTTP APIs"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scala",children:"object ConnectionEndpoints {\n\n  val createConnection: Endpoint[\n    (ApiKeyCredentials, JwtCredentials),\n    (RequestContext, CreateConnectionRequest),\n    ErrorResponse,\n    Connection,\n    Any\n  ] = ???\n\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"use-failure--errorresponse-implicit-conversion",children:'Use "Failure => ErrorResponse" Implicit Conversion'}),"\n",(0,i.jsxs)(n.p,{children:["If all the underlying services used by a controller comply with the above rules, then the only error type that could\npropagate through the effect\u2019s error channel is the\nparent ",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/main/shared/src/main/scala/io/iohk/atala/shared/models/Failure.scala",children:(0,i.jsx)(n.code,{children:"org.hyperledger.identus.shared.models.Failure"})}),"\ntype and its conversion\nto the ErrorResponse type is done automatically\nvia ",(0,i.jsx)(n.a,{href:"https://github.com/hyperledger/identus-cloud-agent/blob/eb898e068f768507d6979a5d9bab35ef7ad4a045/cloud-agent/service/server/src/main/scala/io/iohk/atala/api/http/ErrorResponse.scala#L44",children:"Scala implicit conversion"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"do-not-reflexively-log-errors-3",children:"Do not reflexively log errors"}),"\n",(0,i.jsx)(n.p,{children:"The upper layer will automatically do so appropriately and consistently using Tapir interceptor customization."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var i=r(96540);const t={},o=i.createContext(t);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);